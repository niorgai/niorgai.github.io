<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"niorgai.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta name="description" content="Android | jianqiu&#39;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Jianqiu&#39;s blog">
<meta property="og:url" content="http://niorgai.github.io/page/3/index.html">
<meta property="og:site_name" content="Jianqiu&#39;s blog">
<meta property="og:description" content="Android | jianqiu&#39;s blog">
<meta property="og:locale">
<meta property="article:author" content="Jianqiu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://niorgai.github.io/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>
<title>Jianqiu's blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-59068424-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-59068424-1');
      }
    </script>



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Jianqiu's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Learn More</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jianqiu</p>
  <div class="site-description" itemprop="description">Android | jianqiu's blog</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/niorgai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;niorgai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://niorgai.github.io/2015/12/22/%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEMenuItem%E9%A2%9C%E8%89%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jianqiu">
      <meta itemprop="description" content="Android | jianqiu's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jianqiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/12/22/%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEMenuItem%E9%A2%9C%E8%89%B2/" class="post-title-link" itemprop="url">动态设置MenuItem颜色</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2015-12-22 01:01:33 / Modified: 01:14:13" itemprop="dateCreated datePublished" datetime="2015-12-22T01:01:33+08:00">2015-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Android适配问题</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2015/12/22/%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AEMenuItem%E9%A2%9C%E8%89%B2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/22/动态设置MenuItem颜色/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>为了更好的贴近Google设计规范,开始使用Toolbar自定义布局同时设置为ActionBar,在设置的过程中,为了更好的贴近App风格,MenuItem的颜色就需要改变了.</p>
<ol>
<li><p>style中设置颜色:</p>
<pre><code> &lt;style name=&quot;ActionBarMenuText&quot; parent=&quot;TextAppearance.AppCompat.Widget.ActionBar.Menu&quot;&gt;
     &lt;item name=&quot;android:textColor&quot;&gt;@color/dark_pink&lt;/item&gt;
     &lt;item name=&quot;android:textSize&quot;&gt;@dimen/title_text_size&lt;/item&gt;
     &lt;item name=&quot;android:layout_marginRight&quot;&gt;10dp&lt;/item&gt;
 &lt;/style&gt;</code></pre>
<p> 这种方式在Nexus上测试可以直接改变,当时也就没有太注意,可是突然发现小米竟然没有改变颜色,于是就只能使用反射来改变了</p>
</li>
<li><p>利用反射改变:</p>
<pre><code> public static void setActionBarText(final Activity activity) &#123;
     try &#123;
         final LayoutInflater inflater = activity.getLayoutInflater();
         Field field = LayoutInflater.class.getDeclaredField(&quot;mFactorySet&quot;);
         field.setAccessible(true);
         field.setBoolean(inflater, false);
         LayoutInflaterCompat.setFactory(inflater, new LayoutInflaterFactory() &#123;
             @Override
             public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;
             //因为我使用的是supportv7包
                 if (name.equalsIgnoreCase(&quot;android.support.v7.view.menu.IconMenuItemView&quot;)
                         || name.equalsIgnoreCase(&quot;android.support.v7.view.menu.ActionMenuItemView&quot;)) &#123;
                     final View view;
                     try &#123;
                         view = inflater.createView(name, null, attrs);
                         if (view instanceof TextView)
                             ((TextView) view).setTextColor(activity.getResources().getColor(R.color.dark_pink));
                         return view;
                     &#125; catch (ClassNotFoundException e) &#123;
                         e.printStackTrace();
                     &#125; catch (InflateException ex) &#123;
                         ex.printStackTrace();
                     &#125;
                 &#125;
                 return null;
             &#125;
         &#125;);
     &#125; catch (Exception e) &#123;

     &#125;

 &#125;</code></pre>
<p> 该方法在Activity的onCreate()时调用即可.</p>
</li>
<li><p>无论是style还是反射去改变,都只会在Activity创建时设置一次,创建后不好再改变其颜色.但事实上MenuItem也是一个View,在运行时也可以通过View的寻找方式去动态设置:</p>
<pre><code> View title = getWindow().getDecorView().findViewById(&lt;-- textView的id --&gt;);
 //当然也可以通过findViewByTag()等方法
 if (title != null &amp;&amp; title instanceof TextView) &#123;
    ((TextView) title).setTextColor(getResources().getColor(R.color.dark_pink));
 &#125;</code></pre>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://niorgai.github.io/2015/12/05/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%88%B7%E6%96%B0%E4%B8%8E%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jianqiu">
      <meta itemprop="description" content="Android | jianqiu's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jianqiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/12/05/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%88%B7%E6%96%B0%E4%B8%8E%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">我眼中的刷新与加载</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-12-05 23:43:43" itemprop="dateCreated datePublished" datetime="2015-12-05T23:43:43+08:00">2015-12-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2015-12-06 18:18:24" itemprop="dateModified" datetime="2015-12-06T18:18:24+08:00">2015-12-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android%E5%BC%80%E5%8F%91%E9%97%B2%E8%B0%88/" itemprop="url" rel="index"><span itemprop="name">Android开发闲谈</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2015/12/05/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%88%B7%E6%96%B0%E4%B8%8E%E5%8A%A0%E8%BD%BD/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/05/我眼中的刷新与加载/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>下拉刷新,在我看来是非常有革命性的一种交互形式,使用过程非常自然.而与之对应的,就有上拉加载.为了实现下拉刷新和上拉加载,通常都是将整个界面分为三部分:</p>
<pre><code>*************************
     TopLoadingView
*************************

       childView

*************************
    BottomLoadingView
*************************</code></pre>
<p>###下拉刷新<br>目前常用的下拉刷新有几种样式,在这里推荐一个库<a target="_blank" rel="noopener" href="https://github.com/Aspsine/SwipeToLoadLayout">SwipeToLoadLayout</a>, </p>
<p>这个库的Demo中把刷新的几种样式: </p>
<table>
<thead>
<tr>
<th>名字</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>classic</td>
<td>拉动时LoadingView与childView一起滑动</td>
</tr>
<tr>
<td>above</td>
<td>拉动时只滑动LoadingView, childView不滑动</td>
</tr>
<tr>
<td>below</td>
<td>拉动时只滑动childView,不滑动LoadingView</td>
</tr>
<tr>
<td>scale</td>
<td>拉动时childView跟随拉动距离移动,loadingView滑动较慢</td>
</tr>
</tbody></table>
<p>###上拉加载<br>与下拉刷新相同,上拉加载也可以同时支持这几种样式.</p>
<p>###交互上的细节点:</p>
<ol>
<li>无论是下拉刷新还是上拉加载,手指在整个过程中都不应该离开屏幕,应该让用户感觉更加自然.解决办法如下:<a href="http://niorgai.github.io/2015/10/12/%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-%E8%81%94%E5%8A%A8%E5%AD%90View/">联动子View</a>.</li>
<li>注意与横向滑动View的冲突解决,如<code>ViewPager</code>等.解决方法可以参考<a href="http://niorgai.github.io/2015/10/15/%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-%E6%9B%B4%E5%90%88%E7%90%86%E7%9A%84%E6%8B%A6%E6%88%AA/">更合理的拦截</a>.</li>
<li>下拉刷新是很多App培养出来的用户习惯,用户会习惯性下拉刷新.但是上拉加载却不是,用户并不能很明确得了解是否有更多.同时在除classic的其他模式中,刷新完后loadingView隐藏,界面布局并没有任何变化,用户并不知道是否加载出来.于是就想出一种更加直接的加载**<code>滑动到底部自动加载</code>**.</li>
</ol>
<p>###实现<br><a href="">RefreshView:包含下拉刷新和自动加载的View</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://niorgai.github.io/2015/10/31/Android%E5%8F%B3%E6%BB%91%E8%BF%94%E5%9B%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jianqiu">
      <meta itemprop="description" content="Android | jianqiu's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jianqiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/10/31/Android%E5%8F%B3%E6%BB%91%E8%BF%94%E5%9B%9E/" class="post-title-link" itemprop="url">Android右滑返回</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-10-31 15:50:07" itemprop="dateCreated datePublished" datetime="2015-10-31T15:50:07+08:00">2015-10-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2015-12-05 23:31:09" itemprop="dateModified" datetime="2015-12-05T23:31:09+08:00">2015-12-05</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">Android开发经验</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2015/10/31/Android%E5%8F%B3%E6%BB%91%E8%BF%94%E5%9B%9E/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/10/31/Android右滑返回/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作为一个Android开发者,遇到好的交互当然希望引用过来.iphone的应用可以从屏幕左端右滑返回上一个界面,这个交互在单手操作上非常舒服.那么当然希望在Android上实现.</p>
<p>起初看到知乎和微信都实现了这个功能,于是就自己偷懒没有去想怎么实现,而是先去网上找了一下别人的实现,最后找到了这个<a target="_blank" rel="noopener" href="http://blog.csdn.net/xiaanming/article/details/20934541">Android 向右滑动销毁（finish）Activity, 随着手势的滑动而滑动的效果</a>.作者的原理和代码都很简明,但是copy下来后发现还是有点小bug,于是做了点修复.以及我和它的思路有所区别,最后就没有fork他的库了,而是自己写了一个demo:<a target="_blank" rel="noopener" href="https://github.com/niorgai/SlideFinishLayout">Android 右滑销毁Activity的Layout</a>.</p>
<p>最初实现的时候,我也想像知乎一样可以从屏幕中间滑动,但最后发现知乎并没有ViewPager之类的横向滑动的控件,所以对原来的库做了以下修改:</p>
<ol>
<li>采取了边缘滑动的返回方式.这样便不需要考虑横向滑动的控件的触摸事件冲突.</li>
<li>根据滑动的比例动态改变背景色,使背景色从黑色40%透明到全透明变化,过渡更加自然.</li>
<li>finish()的时候调用<code>overridePendingTransition(0, 0)</code>使Activity的关闭动画取消,用户感觉更加自然.</li>
<li><code>dispatchTouchEvent()</code>中对Move进行判断,这样当子View不消费Touch事件时,<code>slideFinishLayout</code>可以从任意位置滑动返回.</li>
</ol>
<h2 id="待解决优化"><a href="#待解决优化" class="headerlink" title="待解决优化:"></a>待解决优化:</h2><p>因为这里实现滑动返回的是把Activity设为透明,那么上一个Activity的<code>onStop()</code>方法不会被调用,当Activity打开过多,性能下降很快.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://niorgai.github.io/2015/10/15/%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-ViewPager/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jianqiu">
      <meta itemprop="description" content="Android | jianqiu's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jianqiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/10/15/%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-ViewPager/" class="post-title-link" itemprop="url">滑动冲突解决-ViewPager</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-10-15 01:19:27" itemprop="dateCreated datePublished" datetime="2015-10-15T01:19:27+08:00">2015-10-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2017-03-27 13:07:10" itemprop="dateModified" datetime="2017-03-27T13:07:10+08:00">2017-03-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">Android开发经验</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2015/10/15/%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-ViewPager/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/10/15/滑动冲突解决-ViewPager/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>ViewPager</code> 作为一个横向滚动的控件, 在 <code>ViewGroup</code> 中嵌套时会有一些可以优化的细节体验.</p>
<h2 id="案例一-ViewPager-与-SwipeRefreshLayout"><a href="#案例一-ViewPager-与-SwipeRefreshLayout" class="headerlink" title="案例一: ViewPager 与 SwipeRefreshLayout"></a>案例一: <code>ViewPager</code> 与 <code>SwipeRefreshLayout</code></h2><ul>
<li><p>问题说明</p>
<p>  当 <code>SwipeRefreshLayout</code> 中有 <code>ViewPager</code> 控件, 两者的滑动会相互冲突. 具体表现为 <code>ViewPager</code> 的左右滑动不顺畅, 容易被 <code>SwipeRefreshLayout</code> 拦截(即出现刷新的 View ).</p>
</li>
<li><p>问题原因:</p>
<p><code>ViewPager</code> 本身是处理了滚动事件的冲突, 它在横向滑动时会调用 <code>requestDisallowInterceptTouchEvent()</code> 方法使父控件不拦截当前的 Touch 事件序列. 但是 <code>SwipeRefreshLayout</code> 的 <code>requestDisallowInterceptTouchEvent()</code> 方法置空了, 所以仍然会拦截当前的 Touch 事件序列.</p>
</li>
<li><p>问题分析:</p>
<p>  为什么 <code>SwipeRefreshLayout</code> 的 <code>requestDisallowInterceptTouchEvent()</code> 方法什么都不做?</p>
<ul>
<li>首先 <code>SwipeRefreshLayout</code> 继承自 <code>ViewGroup</code> .</li>
<li>在 <code>requestDisallowInterceptTouchEvent()</code> 方法置空的情况下, 用户可以从底部下拉刷新一次拉出 LoadingView (即手指不需要离开屏幕).</li>
<li>如果方法调用 <code>ViewGroup</code> 的 <code>requestDisallowInterceptTouchEvent()</code> 方法, 可以解决 <code>ViewPager</code>的 兼容问题, 但是用户在界面底部下拉至头部后, 无法继续下拉, 需要手指放开一次才能拉出 LoadingView .</li>
</ul>
</li>
<li><p>目标分析:</p>
</li>
</ul>
<p>那么为了更加顺滑地滚动, 想要的效果当然是<strong>一次性拉出 LoadingView **.既然 <code>ViewPager</code> 在左右滑动时才会调用 <code>requestDisallowInterceptTouchEvent()</code> 方法, 那么 <code>SwipeRefreshLayout</code> **只应该在上下滑动时</strong>才拦截 Touch 事件.</p>
<p>代码具体逻辑如下:</p>
<ol>
<li>记录是否调用了 <code>requestDisallowInterceptTouchEvent()</code> 方法,并且设置为true.</li>
<li>在 <code>SwipeRefreshLayout</code> 中判断是否是上下滑动.</li>
<li>如果同时满足1,2, 则调用 <code>super.requestDisallowInterceptTouchEvent(true)</code> 拦截事件.</li>
<li>否则调用 <code>super.requestDisallowInterceptTouchEvent(false)</code> .</li>
</ol>
<p>注意:因为 <code>ViewGroup</code> 的 <code>requestDisallowInterceptTouchEvent</code> 方法返回 true 后, 接下来的 Touch 事件在不会再传递到 <code>onInterceptTouchEvent()</code>方法中, 所以需要在 <code>dispatchTouchEvent()</code> 方法中判断是否为上下滑动.</p>
<ul>
<li><p>实现代码(部分):</p>
<pre><code>  //非法按键
  private static final int INVALID_POINTER = -1;

  //dispatch方法记录第一次按下的x
  private float mInitialDisPatchDownX;

  //dispatch方法记录第一次按下的y
  private float mInitialDisPatchDownY;

  //dispatch方法记录的手指
  private int mActiveDispatchPointerId = INVALID_POINTER;

  //是否请求拦截
  private boolean hasRequestDisallowIntercept = false;

  @Override
  public void requestDisallowInterceptTouchEvent(boolean b) &#123;
      hasRequestDisallowIntercept = b;
      // Nope.
  &#125;

  @Override
  public boolean dispatchTouchEvent(MotionEvent ev) &#123;
      switch (ev.getAction()) &#123;
          case MotionEvent.ACTION_DOWN:
              mActiveDispatchPointerId = MotionEventCompat.getPointerId(ev, 0);
              final float initialDownX = getMotionEventX(ev, mActiveDispatchPointerId);
              if (initialDownX != INVALID_POINTER) &#123;
                  mInitialDisPatchDownX = initialDownX;
              &#125;
              final float initialDownY = getMotionEventY(ev, mActiveDispatchPointerId);
              if (mInitialDisPatchDownY != INVALID_POINTER) &#123;
                  mInitialDisPatchDownY = initialDownY;
              &#125;
              break;
          case MotionEvent.ACTION_MOVE:
              if (hasRequestDisallowIntercept) &#123;
                  //解决viewPager滑动冲突问题
                  final float x = getMotionEventX(ev, mActiveDispatchPointerId);
                  final float y = getMotionEventY(ev, mActiveDispatchPointerId);
                  if (mInitialDisPatchDownX != INVALID_POINTER &amp;&amp; x != INVALID_POINTER &amp;&amp;
                          mInitialDisPatchDownY != INVALID_POINTER &amp;&amp; y != INVALID_POINTER) &#123;
                      final float xDiff = Math.abs(x - mInitialDisPatchDownX);
                      final float yDiff = Math.abs(y - mInitialDisPatchDownY);
                      if (xDiff &gt; mTouchSlop &amp;&amp; xDiff * 0.7f &gt; yDiff) &#123;
                          //横向滚动不需要拦截
                          super.requestDisallowInterceptTouchEvent(true);
                      &#125; else &#123;
                          super.requestDisallowInterceptTouchEvent(false);
                      &#125;
                  &#125; else &#123;
                      super.requestDisallowInterceptTouchEvent(false);
                  &#125;
              &#125;
              break;
          case MotionEvent.ACTION_UP:
          case MotionEvent.ACTION_CANCEL:
              if (ev.getAction() == MotionEvent.ACTION_UP || ev.getAction() == MotionEvent.ACTION_CANCEL) &#123;
                  hasRequestDisallowIntercept = false;
              &#125;
              break;
      &#125;

      return super.dispatchTouchEvent(ev);
  &#125;

  private float getMotionEventY(MotionEvent ev, int activePointerId) &#123;
      final int index = MotionEventCompat.findPointerIndex(ev, activePointerId);
      if (index &lt; 0) &#123;
          return -1;
      &#125;
      return MotionEventCompat.getY(ev, index);
  &#125;

  private float getMotionEventX(MotionEvent ev, int activePointerId) &#123;
      final int index = MotionEventCompat.findPointerIndex(ev, activePointerId);
      if (index &lt; 0) &#123;
          return -1;
      &#125;
      return MotionEventCompat.getX(ev, index);
  &#125;</code></pre>
</li>
</ul>
<h2 id="案例二-ViewPager-与-RecyclerView"><a href="#案例二-ViewPager-与-RecyclerView" class="headerlink" title="案例二: ViewPager 与 RecyclerView"></a>案例二: <code>ViewPager</code> 与 <code>RecyclerView</code></h2><p><img src="http://7sbqys.com1.z0.glb.clouddn.com/viewpager-recyclerview-nested.png"></p>
<p>如上图, <code>RecyclerView</code> 中嵌套 <code>ViewPager</code>. </p>
<ul>
<li><p>问题说明</p>
<ol>
<li>当用户滑动 <code>RecyclerView</code> 后放开手指, <code>RecyclerView</code> 会继续滑动并处于 Fling 状态.</li>
<li>此时用户重新触摸屏幕, <code>RecyclerView</code> 滑动停止, 但是无法左右滑动 <code>ViewPager</code>, 只能上下滑动 <code>RecyclerView</code>.</li>
</ol>
</li>
<li><p>问题原因</p>
<p>  当用户重新触摸屏幕, 此时 <code>RecyclerView</code> 的 <code>onInterceptTouchEvent()</code> 方法还是返回了  true , 所以 <code>ViewGroup</code> 还是继续拦截了事件, 导致 <code>ViewPager</code> 无法处理.</p>
</li>
<li><p>解决思路</p>
<ol>
<li>如果是 Fling 状态的 <code>RecyclerView</code>, 在处理 <code>ACTION_DOWN</code> 事件时, 应该与 IDLE 状态下保持一致.</li>
<li>Fling 状态下处理 <code>ACTION_DOWN</code>, <code>onInterceptTouchEvent()</code> 方法应该返回 false.</li>
</ol>
</li>
<li><p>实现代码:</p>
<pre><code>  @Override
  public boolean onInterceptTouchEvent(MotionEvent e) &#123;
      //isScrolling 为 true 表示是 Fling 状态
      boolean isScrolling = getScrollState() == SCROLL_STATE_SETTLING;
      boolean ans = super.onInterceptTouchEvent(e);
      if (ans &amp;&amp; isScrolling &amp;&amp; e.getAction() == MotionEvent.ACTION_DOWN) &#123;
          //先调用 onTouchEvent() 使 RecyclerView 停下来
          onTouchEvent(e);
          //反射恢复 ScrollState
          try &#123;
              Field field = RecyclerView.class.getDeclaredField(&quot;mScrollState&quot;);
              field.setAccessible(true);
              field.setInt(this, SCROLL_STATE_IDLE);
          &#125; catch (NoSuchFieldException e1) &#123;
              e1.printStackTrace();
          &#125; catch (IllegalAccessException e1) &#123;
              e1.printStackTrace();
          &#125;
          return false;
      &#125;
      return ans;
  &#125;</code></pre>
</li>
</ul>
<h2 id="案例三-ViewPager-与-ScrollView"><a href="#案例三-ViewPager-与-ScrollView" class="headerlink" title="案例三: ViewPager 与 ScrollView"></a>案例三: <code>ViewPager</code> 与 <code>ScrollView</code></h2><p>在 <code>ScrollView</code> 嵌套 <code>ViewPager</code>, Fling 状态下会有跟 <code>RecyclerView</code> 一样的问题, 所以解决思路也是一样的, 只是代码部分有所不同.</p>
<pre><code>    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;
        boolean ans = super.onInterceptTouchEvent(ev);
        if (ans &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN) &#123;
            onTouchEvent(ev);
            Field field = null;
            try &#123;
                field = NestedScrollView.class.getDeclaredField(&quot;mIsBeingDragged&quot;);
            &#125; catch (NoSuchFieldException e) &#123;
                e.printStackTrace();
            &#125;
            if (field != null) &#123;
                field.setAccessible(true);
                try &#123;
                    field.setBoolean(this, false);
                &#125; catch (IllegalAccessException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            return false;
        &#125;
        return ans;
    &#125;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://niorgai.github.io/2015/10/12/refresh_with_child/%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-%E8%81%94%E5%8A%A8%E5%AD%90View/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jianqiu">
      <meta itemprop="description" content="Android | jianqiu's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jianqiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/10/12/refresh_with_child/%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-%E8%81%94%E5%8A%A8%E5%AD%90View/" class="post-title-link" itemprop="url">滑动冲突解决-联动子View</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-10-12 02:32:57" itemprop="dateCreated datePublished" datetime="2015-10-12T02:32:57+08:00">2015-10-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2019-05-30 17:18:30" itemprop="dateModified" datetime="2019-05-30T17:18:30+08:00">2019-05-30</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">Android开发经验</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2015/10/12/refresh_with_child/%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-%E8%81%94%E5%8A%A8%E5%AD%90View/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/10/12/refresh_with_child/滑动冲突解决-联动子View/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在做<a target="_blank" rel="noopener" href="https://github.com/niorgai/SuperRefreshLayout">SuperRefreshLayout</a>这个下拉刷新的控件时,发现了一个问题,这也是很多下拉刷新控件都会有的问题.</p>
<p>如果用户在顶部下拉时触发了控件的下拉效果,此时用户不放手向上滑动,会取消该控件的下拉效果.但是**用户继续向上滑动时,子View却不会向下滚动了.**一定要用户抬起手重新向下滚动才可以.</p>
<p>界面状态分别为:</p>
<table>
<thead>
<tr>
<th>普通状态(图1)</th>
<th>拉动中(图2)</th>
<th>刷新中(图3)</th>
</tr>
</thead>
<tbody><tr>
<td><img src="image/refresh_normal.jpg"></td>
<td><img src="image/refresh_draging.jpg"></td>
<td><img src="image/refresh_refreshing.jpg"></td>
</tr>
</tbody></table>
<p>当用户从普通状态(图1)向下拉动进入拉动中状态(图2),用户向上滑动取消拉动动作,恢复普通状态(图1),此时继续向上滑动,界面并不会跟随用户手指滚动.</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析:"></a>问题分析:</h2><p>外层刷新控件称为RefreshLayout, 内部子控件称为子View.</p>
<ol>
<li><p>RefreshLayout在由图1向下滑动至图2的过程中,其实是RefreshLayout拦截了当前的Touch事件,此时:</p>
<ol>
<li>RefreshLayout的<code>onInterceptTouchEvent()</code>方法返回true,后续的Touch事件都会交给RefreshLayout的<code>onTouchEvent()</code>处理.</li>
<li>子View的<code>dispatchTouchEvent()</code>方法会接收到Action_cancel事件,表示当前触摸事件已经结束,不会再处理接收到的除Action_down之外的事件.</li>
<li>RefreshLayout的<code>onTouchEvent()</code>方法消费Touch事件,界面逐渐变为图2.</li>
</ol>
</li>
<li><p>RefreshLayout由图2向上滑动恢复图1状态后并继续向上滑动时,界面无法向下滑动,因为:</p>
<ol>
<li>RefreshLayout拦截了Touch事件,子View无法接收.</li>
<li>RefreshLayout的<code>onTouchEvent()</code>方法返回false(因为当子View可以向下滑动时不需要处理).</li>
</ol>
</li>
</ol>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路:"></a>解决思路:</h2><p>我们的最终目标就是<strong>把RefreshLayout”错误”拦截的Touch事件交给子View来处理</strong>.</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>原因</th>
<th>解决</th>
</tr>
</thead>
<tbody><tr>
<td>怎么判断是”错误”的拦截</td>
<td>有需要拦截的Touch事件(如滑动到顶部后继续下拉)</td>
<td>在拦截后记录标志位, 在RefreshLayout的<code>onTouchEvent()</code>方法中不该处理(return false)的情况中判断该标志位</td>
</tr>
<tr>
<td>为什么子View无法接收Touch事件</td>
<td>在一开始滚动的过程中RefreshLayout的<code>onInterceptTouchEvent()</code>方法返回true,拦截了所有的Touch事件</td>
<td>事件传递机制是系统设定的,不好更改.但可以在RefreshLayout的<code>onTouchEvent()</code>方法中调用子View的<code>dispatchTouchEvent()</code>方法,让子View接受并处理该Touch事件</td>
</tr>
<tr>
<td>怎么让子View能够处理该Touch事件</td>
<td>RefreshLayout拦截Touch事件后,子View会接收到Action_cancel事件,后续事件无法处理</td>
<td>判断是否为拦截后的第一个Touch事件,是的话先模拟一个Action_down事件并传递给子View,使子View认为这是一个新的Touch事件序列.</td>
</tr>
</tbody></table>
<h2 id="解决代码"><a href="#解决代码" class="headerlink" title="解决代码:"></a>解决代码:</h2><p>以下代码为简略版:</p>
<pre><code>//首先定义一个变量,检测是否是同一点击事件序列中第一个拦截后应该处理的move事件
private boolean isFirstMoveAfterIntercept = false;

 //在dispatchTouchEvent方法中初始化
 @Override
public boolean dispatchTouchEvent(MotionEvent ev) &#123;
    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;
        isFirstMoveAfterIntercept = true;
    &#125;
    if (ev.getAction() == MotionEvent.ACTION_UP || ev.getAction() == MotionEvent.ACTION_CANCEL) &#123;
        isFirstMoveAfterIntercept = false;
    &#125;
    return super.dispatchTouchEvent(ev);
&#125;

@Override
public boolean onTouchEvent(MotionEvent ev) &#123;
    ......
    //mIsBeingDragged表示被拦截了
    if (mIsBeingDragged) &#123;
        //此时是错误的拦截(不需要拦截的情况)
        if (originalDragPercent &lt; 0) &#123;
            //判断是否是拦截后的第一个Move事件
            if (isFirstMoveAfterIntercept) &#123;
                // 先为子View模拟一个Action_Down事件,使其认为这是一个新的Touch事件序列
                MotionEvent event = MotionEvent.obtain(ev);
                event.setAction(MotionEvent.ACTION_DOWN);
                mTarget.dispatchTouchEvent(event);
                isFirstMoveAfterIntercept = false;
            &#125;
            //将Move事件传递到子View
            mTarget.dispatchTouchEvent(ev);
            return false;
        &#125;
        ...
    &#125;
    ....
&#125;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://niorgai.github.io/2015/09/17/ToastUtil%E5%B7%A5%E5%85%B7%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jianqiu">
      <meta itemprop="description" content="Android | jianqiu's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jianqiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/09/17/ToastUtil%E5%B7%A5%E5%85%B7%E7%B1%BB/" class="post-title-link" itemprop="url">ToastUtil工具类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-09-17 23:01:14" itemprop="dateCreated datePublished" datetime="2015-09-17T23:01:14+08:00">2015-09-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2015-11-29 21:28:07" itemprop="dateModified" datetime="2015-11-29T21:28:07+08:00">2015-11-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">Android开发经验</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2015/09/17/ToastUtil%E5%B7%A5%E5%85%B7%E7%B1%BB/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/09/17/ToastUtil工具类/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Android开发固然会用到Toast,如果每次都Toast.makeToast来显示Toast的话,一方面写法麻烦,第二是多次调用Toast会使Toast一直浮在界面最上层,影响交互,最好的方式是封装一个ToastUtil:</p>
<pre><code>public class ToastUtil &#123;

    private static volatile ToastUtil sToastUtil = null;

    private Toast mToast = null;

    /**
     * 获取实例
     *
     * @return
     */
    public static ToastUtil getInstance() &#123;
        if (sToastUtil == null) &#123;
            synchronized (ToastUtil.class) &#123;
                if (sToastUtil == null) &#123;
                    sToastUtil = new ToastUtil();
                &#125;
            &#125;
        &#125;
        return sToastUtil;
    &#125;

    protected Handler handler = new Handler(Looper.getMainLooper());

    /**
     * 显示Toast，多次调用此函数时，Toast显示的时间不会累计，并且显示内容为最后一次调用时传入的内容
     * 持续时间默认为short
     * @param tips 要显示的内容
     *            &#123;@link Toast#LENGTH_LONG&#125;
     */
    public void showToast(final String tips)&#123;
        showToast(tips, Toast.LENGTH_SHORT);
    &#125;

    public void showToast(final int tips)&#123;
        showToast(tips, Toast.LENGTH_SHORT);
    &#125;
    /**
     * 显示Toast，多次调用此函数时，Toast显示的时间不会累计，并且显示内容为最后一次调用时传入的内容
     *
     * @param tips 要显示的内容
     * @param duration 持续时间，参见&#123;@link Toast#LENGTH_SHORT&#125;和
     *            &#123;@link Toast#LENGTH_LONG&#125;
     */
    public void showToast(final String tips, final int duration) &#123;
        if (android.text.TextUtils.isEmpty(tips)) &#123;
            return;
        &#125;
        handler.post(new Runnable() &#123;
            @Override
            public void run() &#123;
                if (mToast == null) &#123;
                    mToast = Toast.makeText(MyApplication.getMyApplicationContext(), tips, duration);
                    mToast.show();
                &#125; else &#123;
                    //mToast.cancel();
                    //mToast.setView(mToast.getView());
                    mToast.setText(tips);
                    mToast.setDuration(duration);
                    mToast.show();
                &#125;
            &#125;
        &#125;);
    &#125;

    public void showToast(final int tips, final int duration) &#123;
        handler.post(new Runnable() &#123;
            @Override
            public void run() &#123;
                if (mToast == null) &#123;
                    mToast = Toast.makeText(MyApplication.getMyApplicationContext(), tips, duration);
                    mToast.show();
                &#125; else &#123;
                    //mToast.cancel();
                    //mToast.setView(mToast.getView());
                    mToast.setText(tips);
                    mToast.setDuration(duration);
                    mToast.show();
                &#125;
            &#125;
        &#125;);
    &#125;
&#125;</code></pre>
<p>其实Toast调用的Context为ApplicationContext,在Application中初始化即可.</p>
<pre><code>public class MyApplication extends Application &#123;

    private static Context myContext;

    @Override
    public void onCreate() &#123;
        super.onCreate();
        myContext = this.getApplicationContext();
    &#125;

    public static Context getMyApplicationContext()&#123;
        return myContext;
    &#125;
&#125;</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://niorgai.github.io/2015/03/23/Android%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jianqiu">
      <meta itemprop="description" content="Android | jianqiu's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jianqiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/03/23/Android%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/" class="post-title-link" itemprop="url">Android文件存储</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-03-23 10:04:39" itemprop="dateCreated datePublished" datetime="2015-03-23T10:04:39+08:00">2015-03-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2015-11-29 21:19:31" itemprop="dateModified" datetime="2015-11-29T21:19:31+08:00">2015-11-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">Android基础知识</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2015/03/23/Android%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/03/23/Android文件存储/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>文件存储分内部文件存储和外部存储。</p>
<p>默认情况下应用安装到内部存储，可以通过<code>AndroidMainfest.xml</code>文件下<code>application</code>的<code>android:installLocation</code>属性设置安装位置。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>内部存储</th>
<th>外部存储</th>
</tr>
</thead>
<tbody><tr>
<td>可用</td>
<td>一直可用</td>
<td>没有挂载时不可用</td>
</tr>
<tr>
<td>可访问性</td>
<td>只能被自己的APP访问</td>
<td>全部可读</td>
</tr>
<tr>
<td>删除</td>
<td>卸载应用时清除</td>
<td>只有通过<code>getExternalFilesDir()</code>方法返回的路径的文件才会被删除</td>
</tr>
</tbody></table>
<p>读取外部存储时,需要添加以下权限:</p>
<pre><code>写入的权限已经在SDK&gt;18的版本中默认拥有了
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;
                 android:maxSdkVersion=&quot;18&quot; /&gt;

&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</code></pre>
<hr>
<p>内部存储</p>
<ol>
<li><p><code>getFilesDir()</code> </p>
<p> 返回app可用的内部存储文件地址。</p>
</li>
<li><p><code>getCacheDir()</code> </p>
<p> 返回app可用的缓存文件地址。当缓存较大并且系统空间不足时会删除其中的文件。</p>
</li>
</ol>
<p>内部存储保存文件：</p>
<pre><code>File file = new File(context.getFilesDir(), filename);
String filename = &quot;myfile&quot;;
String string = &quot;Hello world!&quot;;
FileOutputStream outputStream;

try &#123;
      outputStream = openFileOutput(filename, Context.MODE_PRIVATE);
      outputStream.write(string.getBytes());
      outputStream.close();
    &#125; catch (Exception e) &#123;
          e.printStackTrace();
&#125;</code></pre>
<p>设置<code>MODE_PRIVATE</code>可以使其他应用无法访问文件。</p>
<p>内部存储保存缓存文件：</p>
<pre><code>public File getTempFile(Context context, String url) &#123;
    File file;
    try &#123;
        String fileName = Uri.parse(url).getLastPathSegment();
        file = File.createTempFile(fileName, null, context.getCacheDir());
    catch (IOException e) &#123;
        // Error while creating file
    &#125;
    return file;
&#125;</code></pre>
<hr>
<p>外部存储</p>
<p>因为外部存储可能没有被挂载，所以需要先判断是否可用：</p>
<pre><code>/* Checks if external storage is available for read and write */
public boolean isExternalStorageWritable() &#123;
    String state = Environment.getExternalStorageState();
    if (Environment.MEDIA_MOUNTED.equals(state)) &#123;
        return true;
    &#125;
    return false;
&#125;

/* Checks if external storage is available to at least read */
public boolean isExternalStorageReadable() &#123;
    String state = Environment.getExternalStorageState();
    if (Environment.MEDIA_MOUNTED.equals(state) ||
        Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123;
        return true;
    &#125;
    return false;
&#125;</code></pre>
<ol>
<li><p><code>getExternalStoragePublicDirectory()</code></p>
<p> 返回可以任意访问的外部存储路径，删除应用时不会清除该路径。</p>
</li>
<li><p><code>getExternalFilesDir()</code></p>
<p> 返回只能自己访问的外部存储路径，删除应用时该目录下的文件会被删除。</p>
</li>
</ol>
<hr>
<p><code>getFreeSpace ()</code>和<code>getTotalSpace ()</code>会返回路径下的可用空间和全部空间的字节。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://niorgai.github.io/2015/03/19/Handler%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jianqiu">
      <meta itemprop="description" content="Android | jianqiu's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jianqiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/03/19/Handler%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/" class="post-title-link" itemprop="url">Handler原理浅析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-03-19 21:52:44" itemprop="dateCreated datePublished" datetime="2015-03-19T21:52:44+08:00">2015-03-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2015-11-29 21:22:15" itemprop="dateModified" datetime="2015-11-29T21:22:15+08:00">2015-11-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">Android基础知识</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2015/03/19/Handler%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/03/19/Handler原理浅析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在<a href="http://niorgai.github.io/2015/01/14/Android%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/">Android线程相关</a>这篇文章中说到了利用handler实现多线程并通信的方法，于是翻阅了很多博客，也查看了源码，终于从自己的角度理解了handler的原理。于是来梳理一下～</p>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/9991569">Android异步消息处理机制完全解析，带你从源码的角度彻底理解</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/mylzc/article/details/6771331">Android异步处理三：Handler+Looper+MessageQueue深入详解</a></li>
</ol>
<p>以线程A为主线程，B为新线程为例：</p>
<ol>
<li><strong>A线程</strong>通过<code>Looper.prepare()</code>创建Looper对象，并初始化其MessageQueue消息队列，此时Looper与线程A绑定。</li>
<li><strong>A线程</strong>中new handler对象，构造函数中绑定Looper对象，同时也绑定了MessageQueue。</li>
<li>新建<strong>线程B</strong>，并执行操作，最后通过A线程中的handler调用<code>sendMessage()</code>方法或<code>post()</code>方法使Message入队Looper中的MessageQueue。</li>
<li><strong>A线程</strong>中的Looper对象通过调用<code>Looper.loop()</code>方法使MessageQueue中的Message不断出队，并分发到handler中。</li>
<li><strong>A线程</strong>中的handler的handleMessage方法处理回调。</li>
</ol>
<p>从源码的角度：</p>
<ol>
<li><p><code>Looper.prepare()</code>，即初始化Looper对象，及MessageQueue，同时绑定线程(ThreadLocal).</p>
<pre><code> static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();
 private static Looper sMainLooper;  // guarded by Looper.class

 final MessageQueue mQueue;
 final Thread mThread;

 public static void prepare() &#123;
     prepare(true);
 &#125;

 private static void prepare(boolean quitAllowed) &#123;
     if (sThreadLocal.get() != null) &#123;
         throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
     &#125;
     sThreadLocal.set(new Looper(quitAllowed));
 &#125;

 private Looper(boolean quitAllowed) &#123;
     mQueue = new MessageQueue(quitAllowed);
     mThread = Thread.currentThread();
 &#125;</code></pre>
</li>
<li><p><code>Handler handler = new Handler()</code>，新建hanlder对象，同时绑定Looper对象及MessageQueue。</p>
<pre><code> public Handler(Callback callback, boolean async) &#123;
 if (FIND_POTENTIAL_LEAKS) &#123;
     final Class&lt;? extends Handler&gt; klass = getClass();
     if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
             (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;
         Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +
             klass.getCanonicalName());
     &#125;
 &#125;

 mLooper = Looper.myLooper();
 if (mLooper == null) &#123;
     throw new RuntimeException(
         &quot;Can&#39;t create handler inside thread that has not called Looper.prepare()&quot;);
 &#125;
 mQueue = mLooper.mQueue;
 mCallback = callback;
 mAsynchronous = async;</code></pre>
<p> }</p>
</li>
<li><p>新建线程B，在其runnable的run方法中调用线程A的handler的<code>sendMessage(Message)</code>或<code>post(Runnable)</code>方法，这两种方法最后都会调用handler中MessageQueue的<code>enqueueMessage</code>方法。该方法使Message按时间顺序排列。</p>
</li>
</ol>
<pre><code>`post(Runnable)`方法会新建带有Runnable对象的Message对象，然后在辗转调用`enqueueMessage`方法。

    public final boolean post(Runnable r)
    &#123;
           return  sendMessageDelayed(getPostMessage(r), 0);
    &#125;

    boolean enqueueMessage(Message msg, long when) &#123;
        if (msg.target == null) &#123;
            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
        &#125;
        if (msg.isInUse()) &#123;
            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
        &#125;

        synchronized (this) &#123;
            if (mQuitting) &#123;
                IllegalStateException e = new IllegalStateException(
                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);
                Log.w(&quot;MessageQueue&quot;, e.getMessage(), e);
                msg.recycle();
                return false;
            &#125;

            msg.markInUse();
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when &lt; p.when) &#123;
                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            &#125; else &#123;
                // Inserted within the middle of the queue.  Usually we don&#39;t have to wake
                // up the event queue unless there is a barrier at the head of the queue
                // and the message is the earliest asynchronous message in the queue.
                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
                Message prev;
                for (;;) &#123;
                    prev = p;
                    p = p.next;
                    if (p == null || when &lt; p.when) &#123;
                        break;
                    &#125;
                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;
                        needWake = false;
                    &#125;
                &#125;
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            &#125;

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) &#123;
                nativeWake(mPtr);
            &#125;
        &#125;
        return true;
    &#125;</code></pre>
<ol start="4">
<li><p><code>Looper.loop()</code>通过死循环使MessageQueue中的Message出队直到队列为空，message.target即为handler的回调。</p>
<pre><code> public static void loop() &#123;
     final Looper me = myLooper();
     if (me == null) &#123;
         throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);
     &#125;
     final MessageQueue queue = me.mQueue;

     // Make sure the identity of this thread is that of the local process,
     // and keep track of what that identity token actually is.
     Binder.clearCallingIdentity();
     final long ident = Binder.clearCallingIdentity();

     for (;;) &#123;
         Message msg = queue.next(); // might block
         if (msg == null) &#123;
             // No message indicates that the message queue is quitting.
             return;
         &#125;

         // This must be in a local variable, in case a UI event sets the logger
         Printer logging = me.mLogging;
         if (logging != null) &#123;
             logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                     msg.callback + &quot;: &quot; + msg.what);
         &#125;

         msg.target.dispatchMessage(msg);

         if (logging != null) &#123;
             logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
         &#125;

         // Make sure that during the course of dispatching the
         // identity of the thread wasn&#39;t corrupted.
         final long newIdent = Binder.clearCallingIdentity();
         if (ident != newIdent) &#123;
             Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;
                 + Long.toHexString(ident) + &quot; to 0x&quot;
                 + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                 + msg.target.getClass().getName() + &quot; &quot;
                 + msg.callback + &quot; what=&quot; + msg.what);
         &#125;

         msg.recycleUnchecked();
     &#125;
 &#125;</code></pre>
</li>
<li><p>handler重写<code>handleMessage</code>方法处理回调，可以看到<code>dispatchMessage</code>方法即先判断有没有callback，而callback就是handler构造函数中的callback。</p>
<pre><code> public void dispatchMessage(Message msg) &#123;
     if (msg.callback != null) &#123;
         handleCallback(msg);
     &#125; else &#123;
         if (mCallback != null) &#123;
             if (mCallback.handleMessage(msg)) &#123;
                    return;
             &#125;
         &#125;
         handleMessage(msg);
     &#125;
 &#125;</code></pre>
</li>
</ol>
<hr>
<p>所以标准的线程通信写法为(可以从Looper的源码中看到)：</p>
<pre><code>class LooperThread extends Thread &#123;
      public Handler mHandler;

  public void run() &#123;
      Looper.prepare();

      mHandler = new Handler() &#123;
          public void handleMessage(Message msg) &#123;
              // process incoming messages here
          &#125;
      &#125;;

      Looper.loop();
  &#125;</code></pre>
<p>  }</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://niorgai.github.io/2015/03/19/Android-Studio%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jianqiu">
      <meta itemprop="description" content="Android | jianqiu's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jianqiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/03/19/Android-Studio%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Android Studio开发遇到的问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-03-19 10:14:47" itemprop="dateCreated datePublished" datetime="2015-03-19T10:14:47+08:00">2015-03-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2016-02-27 01:09:17" itemprop="dateModified" datetime="2016-02-27T01:09:17+08:00">2016-02-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">Android开发工具</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2015/03/19/Android-Studio%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/03/19/Android-Studio开发遇到的问题/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><p>Android studio卡顿优化</p>
<p> 除了机器配置之外,也可以给Android Studio分配更多内存.<br> 打开Android Studio的安装目录,Mac下进入bin目录,打开studio.vmoptions文件,<br> 修改以下配置</p>
<ol>
<li><p>-Xms:JVM堆内存,默认是物理内存的1/64.</p>
</li>
<li><p>-Xmx:JVM最大内存,默认是物理内存的1/4.</p>
</li>
<li><p>-XX:MaxPermSize:最大非堆内存,默认是物理内存的1/4.</p>
</li>
<li><p>-XX:ReservedCodeCacheSize:缓存大小.</p>
<p>把这些调大就好了~</p>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>Gradle没有自动下载dependence包。</p>
<p> 解决方法：</p>
<ol>
<li>检查gradle环境。</li>
<li>   在工程目录下依次运行<code>gradle clean</code> , <code>gradle assemble</code></li>
</ol>
</li>
<li><p><code>Executor Singleton not started</code></p>
<p> 升级一下gradle到最新版本,然后在project的build.gradle中修改gradle版本即可.</p>
</li>
<li><p>adb连接不到手机</p>
<p> 以魅族mx4为例，直接连接手机的话其实是识别不到的，adb连接需要添加机器的Vender ID。</p>
<ul>
<li><p>连接电脑，打开终端，输入</p>
<pre><code>  system_profiler SPUSBDataType</code></pre>
</li>
<li><p>找到手机(mx4)，复制Vender ID（我的是0x2a45）,注意只复制内容，然后进入adb_usb.ini文件。</p>
<pre><code>  sudo vim ~/.android/adb_usb.ini</code></pre>
</li>
<li><p>将Vender ID直接复制在下面就好。然后依次输入</p>
<pre><code>  adb kill-server    
  adb start-server</code></pre>
</li>
</ul>
<p> <strong>注意adb_usb.ini这个文件不能有错误的行，或者vim打开产生的缓存文件没有删除，这样会导致无法运行adb</strong></p>
<p> 顺便说一下环境变量的配置</p>
<p> 首先进入.bashrc(使用bash的话是<del>/.bashrc,使用zsh的话是</del>/.zshrc)文件：</p>
<pre><code> vim ~/.bashrc</code></pre>
<p> 然后添加格式为：</p>
<pre><code> export PATH=&quot;/Users/qiu/Documents/adt-bundle-mac-x86_64-20140702/sdk/tools:$PATH&quot;</code></pre>
<p> 这样环境变量便是append进去了，不会覆盖PATH。<br> 最后记得更新一下环境变量：</p>
<pre><code> source ~/.bashrc</code></pre>
</li>
</ol>
<ol start="5">
<li><p>工程不在根目录下，比如在Test工程下又添加了Test1工程，就像这样:<img src="http://7sbqys.com1.z0.glb.clouddn.com/intelTest.jpg"></p>
<p> 然后因为找不到AndroidManifest.xml文件导致无法运行。</p>
<p> <strong>解决方法如下：</strong></p>
<ul>
<li>File-&gt;Project Structure</li>
<li>在左边点击Facets</li>
<li>找到你的项目，没有就添加一个</li>
<li>把Structure里面的路径全部替换为当前实际工程的项目。</li>
<li>顺利运行。</li>
</ul>
</li>
<li><p>java <code>finished with non-zero exit value x</code>error code问题,常见的code有:</p>
<ol>
<li><p>vcs缓存与新添加的资源冲突,clean 工程再重新运行即可.</p>
</li>
<li><p>有两种情况:</p>
<ol>
<li>可能是libs中添加了重复包,这时候需要看看是哪两个依赖重复了,然后去掉一个.</li>
<li>可能是方法数过了65535.这时候就需要multi-dex分包了.</li>
</ol>
</li>
<li><p>这个我在分包后出现过,目前解决方法是在<code>build.gradle</code>文件中添加:</p>
<pre><code> dexOptions &#123;
     preDexLibraries = false
     incremental true
     javaMaxHeapSize &quot;4g&quot;
 &#125;</code></pre>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://niorgai.github.io/2015/03/11/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jianqiu">
      <meta itemprop="description" content="Android | jianqiu's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jianqiu's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/03/11/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">布局优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-03-11 22:07:12" itemprop="dateCreated datePublished" datetime="2015-03-11T22:07:12+08:00">2015-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2019-05-29 17:50:41" itemprop="dateModified" datetime="2019-05-29T17:50:41+08:00">2019-05-29</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">Android开发经验</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2015/03/11/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/03/11/布局优化/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>布局就是页面的直接表现, 加载过程为 measure - layout - draw.</p>
<p>以此来:</p>
<ol>
<li>能不先加载就不先加载 - 懒加载.</li>
<li>减少嵌套.</li>
<li>减少个数.</li>
</ol>
<ul>
<li>使用 ViewStub 做懒加载.</li>
<li>TextView setCompoundDrawables 减少 View 的个数.</li>
<li>根布局 FrameLayout 使用 merge 代替.</li>
<li>集成 ViewGroup 时使用 merge.</li>
<li>使用 ConstraintLayout 减少嵌套.</li>
<li>space 控件占位.</li>
<li>clipToPadding 和 ClipChildren 可以使 View Draw 到布局外面, 也是减少嵌套的方法.</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jianqiu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://blog-niorgai.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
